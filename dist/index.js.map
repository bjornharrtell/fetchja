{
  "version": 3,
  "sources": ["../src/index.js", "../src/utils/deattribute.js", "../src/utils/deserialize.js", "../src/utils/error-parser.js", "../src/utils/serialize.js", "../src/utils/query-formatter.js", "../src/utils/split-model.js", "../src/utils/camel-case.js", "../src/utils/kebab-case.js", "../src/utils/snake-case.js"],
  "sourcesContent": ["import pluralize from 'pluralize'\n\nimport { deserialize } from './utils/deserialize.js'\nimport { serialize } from './utils/serialize.js'\n\nimport { errorParser } from './utils/error-parser.js'\nimport { queryFormatter } from './utils/query-formatter.js'\nimport { splitModel } from './utils/split-model.js'\n\nimport { camelCase } from './utils/camel-case.js'\nimport { kebabCase } from './utils/kebab-case.js'\nimport { snakeCase } from './utils/snake-case.js'\n\nconst jsonType = 'application/vnd.api+json'\n\n/**\n * Options for Fetchja.\n * \n * @typedef {Object} FetchjaOptions\n * @property {string} baseURL The base URL for all requests.\n * @property {Object} headers The headers to include in all requests.\n * @property {Function} queryFormatter A function to format query parameters.\n * @property {string} resourceCase The case to use for resource names.\n * @property {boolean} pluralize Pluralize resource names.\n */\n\n/**\n * Fetchja is a simple wrapper around the Fetch API.\n * \n * @class Fetchja\n * @param {FetchjaOptions} [options] Options for Fetchja.\n */\nexport default class Fetchja {\n  constructor (options = {\n    headers: {}\n  }) {\n    this.baseURL = options.baseURL\n\n    // Headers\n    this.headers = {\n      Accept: jsonType,\n      'Content-Type': jsonType,\n      ...options.headers\n    }\n\n    // Query\n    this.queryFormatter = typeof options.queryFormatter === 'function'\n      ? options.queryFormatter\n      : object => queryFormatter(object)\n\n    // Camel Case Types\n    this.camelCaseTypes = options.camelCaseTypes === false\n      ? string => string\n      : camelCase\n\n    // Resource Case\n    const cases = {\n      camel: camelCase,\n      kebab: kebabCase,\n      snake: snakeCase,\n\n      default: string => string\n    }\n\n    this.resourceCase = cases[options.resourceCase] || cases.default\n    \n    // Pluralise\n    this.pluralize = options.pluralize === false\n      ? string => string\n      : pluralize\n    \n    // Interceptors\n    this.onResponseError = error => error\n\n    // Alias\n    this.fetch = this.get\n    this.update = this.patch\n    this.create = this.post\n    this.remove = this.delete\n  }\n\n  #splitModel (model) {\n    return splitModel(model, {\n      resourceCase: this.resourceCase,\n      pluralize: this.pluralize\n    })\n  }\n\n  async request (options = {\n    method: 'GET',\n    headers: {}\n  }) {\n    const url = new URL(options.url, this.baseURL || options.baseURL)\n\n    // Params\n    if (options.params) {\n      url.search = this.queryFormatter(options.params)\n    }\n\n    // Body\n    if (options.body) {\n      options.body = serialize(options.type, options.body, {\n        camelCaseTypes: this.camelCaseTypes,\n        pluralTypes: this.pluralize\n      })\n    }\n\n    // Request\n    const makeRequest = () => {\n      // Headers\n      const headers = new Headers({\n        ...this.headers,\n        ...options.headers\n      })\n\n      // Fetch\n      return fetch(url, {\n        method: options.method,\n        body: options.body,\n        headers\n      })\n    }\n\n    try {\n      let response = await makeRequest()\n\n      if (!response.ok) {\n        response.replayRequest = makeRequest\n        const replayedResponse = await this.onResponseError(response)\n\n        if (replayedResponse instanceof Response) {\n          response = replayedResponse\n        }\n      } else if (!response.ok) {\n        throw new Error(response.statusText)\n      }\n\n      // Response Headers\n      const responseHeaders = {}\n\n      for (const [key, value] of response.headers.entries()) {\n        responseHeaders[key] = value\n      }\n\n      const contentType = responseHeaders['content-type']\n\n      // Response Data\n      const data = contentType && contentType.includes(jsonType)\n        ? await response.json()\n        : {}\n\n      // Return\n      return {\n        ...deserialize(data),\n\n        status: response.status,\n        statusText: response.statusText,\n        headers: responseHeaders\n      }\n    } catch (error) {\n      throw error\n    }\n  }\n\n  get (model, options = { method: 'GET' }) {\n    try {\n      options.url = model.split('/')\n        .map(part => this.resourceCase(part))\n        .filter(Boolean)\n        .join('/')\n\n      return this.request(options)\n    } catch (error) {\n      throw errorParser(error)\n    }\n  }\n\n  patch (model, body, options = { method: 'PATCH' }) {\n    try {\n      const [type, url] = this.#splitModel(model)\n\n      return this.request({\n        url: body?.id ? `${url}/${body.id}` : url,\n        body,\n        type,\n\n        ...options\n      })\n    } catch (error) {\n      throw errorParser(error)\n    }\n  }\n\n  post (model, body, options = { method: 'POST' }) {\n    try {\n      const [type, url] = this.#splitModel(model)\n\n      return this.request({\n        url,\n        body,\n        type,\n\n        ...options\n      })\n    } catch (error) {\n      throw errorParser(error)\n    }\n  }\n\n  delete (model, id, options = { method: 'DELETE' }) {\n    try {\n      const [type, url] = this.#splitModel(model)\n\n      return this.request({\n        url: `${url}/${id}`,\n        body: { id },\n        type,\n\n        ...options\n      })\n    } catch (error) {\n      throw errorParser(error)\n    }\n  }\n}\n", "/**\n * Deattribute JSON:API data.\n *\n * @param {Object|Object[]} data The JSON:API data to deattribute.\n * @returns {Object} The deattributed data.\n */\nexport function deattribute (data) {\n  if (Array.isArray(data)) {\n    return data.map(deattribute)\n  }\n\n  const output = {\n    id: data.id,\n    type: data.type\n  }\n\n  for (const key in data.attributes) {\n    output[key] = data.attributes[key]\n  }\n\n  for (const key in data.relationships) {\n    if (data.relationships[key].data) {\n      output[key] = data.relationships[key].data\n    }\n  }\n\n  return output\n}", "import { deattribute } from './deattribute.js'\n\n/**\n * Group included JSON:API data by type and ID.\n *\n * @param {Object[]} included The included JSON:API data.\n * @returns {Object} The grouped included data.\n */\nfunction groupIncluded (included) {\n  const groups = {}\n\n  for (const item of included) {\n    if (!groups[item.type]) {\n      groups[item.type] = {}\n    }\n\n    groups[item.type][item.id] = deattribute(item)\n  }\n\n  return groups\n}\n\n/**\n * Deserialises a JSON-API response.\n *\n * @param {Object} response The JSON-API response.\n * @returns {Object} The deserialised response.\n */\nexport function deserialize (response) {\n  const output = {}\n\n  if (response.data) {\n    output.data = deattribute(response.data)\n  }\n\n  if (response.meta) {\n    output.meta = response.meta\n  }\n\n  if (response.included) {\n    const included = groupIncluded(response.included)\n    const getIncluded = item => included[item.type][item.id]\n\n    for (const item of output.data) {\n      for (const key in item) {\n        const itemKey = item[key]\n\n        if (typeof itemKey === 'object') {\n          item[key] = Array.isArray(itemKey)\n            ? itemKey.map(getIncluded)\n            : getIncluded(itemKey)\n        }\n      }\n    }\n  }\n\n  return output\n}", "/**\n * Parse the error response from the API.\n *\n * @param {Object} error The error object.\n * @throws {Error} The parsed error object.\n */\nexport function errorParser (error) {\n  if (error.response) {\n    const { data } = error.response\n\n    if (data?.errors) {\n      error.errors = data.errors\n    }\n  }\n\n  throw error\n}\n", "import { errorParser } from './error-parser.js'\n\nfunction serializeNode (node, key, data) {\n  if (typeof node === 'object' && node !== null) {\n    if (!data.relationships) {\n      data.relationships = {}\n    }\n\n    data.relationships[key] = {\n      data: node.id ? { id: node.id, type: node.type || key } : node,\n      links: node.links,\n      meta: node.meta\n    }\n  } else {\n    if (!data.attributes) {\n      data.attributes = {}\n    }\n\n    data.attributes[key] = node\n  }\n\n  return data\n}\n\nexport function serialize (type, data, options = {\n  camelCaseTypes: string => string,\n  pluralTypes: string => string\n}) {\n  try {\n    if (data === null || (Array.isArray(data) && !data.length)) {\n      return { data }\n    }\n\n    const output = {\n      type: options.pluralTypes(options.camelCaseTypes(type))\n    }\n\n    if (data.id) {\n      output.id = String(data.id)\n    }\n\n    for (const key in data) {\n      if (['id', 'type'].includes(key)) {\n        continue\n      }\n\n      serializeNode(data[key], key, output)\n    }\n\n    return  JSON.stringify({ data: output })\n  } catch (error) {\n    errorParser(error)\n  }\n}", "/**\n * Loop through an object and build a query string.\n * \n * @param {URLSearchParams} query The query to append to.\n * @param {Object} object The object to loop through.\n * @param {string} prefix The prefix to use.\n * @returns {void}\n * @private\n */\nfunction buildQuery (query, object = {}, prefix = '') {\n  const isArray = Array.isArray(object)\n\n  for (const key in object) {\n    const value = object[key]\n    const withPrefix = prefix ? `${prefix}[${isArray ? '' : key}]` : key\n\n    value instanceof Object\n      ? buildQuery(query, value, withPrefix)\n      : query.append(withPrefix, value)\n  }\n}\n\n/**\n * Format query parameters.\n * \n * @param {Object} parameters The parameters to format.\n * @returns {URLSearchParams} The formatted query.\n */\nexport function queryFormatter (parameters = {}) {\n  const query = new URLSearchParams()\n  buildQuery(query, parameters)\n\n  return query\n}\n", "/**\n * Split a model name from a URL.\n *\n * @param {string} url The URL to split.\n * @param {Object} options The options to use.\n * @returns {string[]} The model and resource.\n */\nexport function splitModel (url, options = {\n  resourceCase: string => string,\n  pluralize: string => string\n}) {\n  const parts = url.split('/')\n  const model = parts.pop()\n  const resource = parts.join('/')\n\n  return [\n    model,\n    `${resource}/${options.pluralize(options.resourceCase(model))}`\n  ]\n}\n", "/**\n * Convert a string from snake_case and kebab-case to camelCase.\n *\n * @param {string} input The string to convert.\n * @returns {string} The converted string.\n */\nexport function camelCase (input) {\n  return input\n    .toLowerCase()\n    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())\n    .replace(/^(.)/, (char) => char.toLowerCase())\n}\n", "/**\n * Convert a string from camelCase and snake_case to kebab-case.\n *\n * @param {string} input The string to convert.\n * @returns {string} The converted string.\n */\nexport function kebabCase (input) {\n  return input\n    .replace(/([a-z])([A-Z])/g, '$1-$2')\n    .replace(/_/g, '-')\n    .toLowerCase()\n}\n", "/**\n * Converts a string from camelCase and kebab-case to snake_case.\n *\n * @param {string} input The string to convert.\n * @returns {string} The converted string.\n */\nexport function snakeCase (input) {\n  return input\n  .replace(/([a-z])([A-Z])/g, '$1_$2')\n  .replace(/-/g, '_')\n  .toLowerCase()\n}\n"],
  "mappings": "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",
  "names": ["pluralize", "deattribute", "data", "output", "key", "groupIncluded", "included", "groups", "item", "deattribute", "deserialize", "response", "output", "getIncluded", "key", "itemKey", "errorParser", "error", "data", "serializeNode", "node", "key", "data", "serialize", "type", "options", "string", "output", "error", "errorParser", "buildQuery", "query", "object", "prefix", "isArray", "key", "value", "withPrefix", "queryFormatter", "parameters", "splitModel", "url", "options", "string", "parts", "model", "resource", "camelCase", "input", "_", "char", "kebabCase", "input", "snakeCase", "input", "jsonType", "Fetchja", "options", "object", "queryFormatter", "string", "camelCase", "cases", "kebabCase", "snakeCase", "pluralize", "error", "#splitModel", "model", "splitModel", "url", "serialize", "makeRequest", "headers", "response", "replayedResponse", "responseHeaders", "key", "value", "contentType", "data", "deserialize", "part", "errorParser", "body", "type", "id"]
}
